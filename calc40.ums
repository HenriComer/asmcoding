# calc40.ums

.section data
.section vstk
        .space 10000
valstack_end:

.section rodata
jumptable:
        .space 256

.section init
.zero r0
.temps r6, r7

init_calc:
        r3 := valstack_end
        r4 := 0
init_loop:
        r6 := 256
        if (r4 >=s r6) goto init_jumptable_done using r5
        r6 := jumptable
        r6 := r6 + r4
        m[r0][r6] := input_error
        r4 := r4 + 1

init_jumptable_done:
        r4 := '0'
# digit_init_loop:
#         output "In digit loop\n"
#         r6 := '9'
#         if (r4 >s r6) goto digit_init_done using r5
#         r6 := jumptable
#         r6 := r6 + r4
#         m[r0][r6] := digit
#         r4 := r4 + 1
#         goto digit_init_loop

digit_inits:
        m[r0][jumptable + '0'] := digit
        m[r0][jumptable + '1'] := digit
        m[r0][jumptable + '2'] := digit
        m[r0][jumptable + '3'] := digit
        m[r0][jumptable + '4'] := digit
        m[r0][jumptable + '5'] := digit
        m[r0][jumptable + '6'] := digit
        m[r0][jumptable + '7'] := digit
        m[r0][jumptable + '8'] := digit
        m[r0][jumptable + '9'] := digit

digit_init_done:
        output "IN DIGIT INIT\n"
        m[r0][jumptable + ' '] := waiting
        m[r0][jumptable + '\n'] := newline
        m[r0][jumptable + '+'] := add
        m[r0][jumptable + '-'] := sub
        m[r0][jumptable + '*'] := mul
        m[r0][jumptable + '/'] := div
        m[r0][jumptable + '|'] := or
        m[r0][jumptable + '&'] := and
        m[r0][jumptable + 'c'] := c
        m[r0][jumptable + '~'] := not
        m[r0][jumptable + 's'] := swap
        m[r0][jumptable + 'd'] := dup
        m[r0][jumptable + 'p'] := pop_stack
        m[r0][jumptable + 'z'] := zero

.section text

underflow1:
        output "Stack underflow---expected at least 1 element\n"
        goto waiting

underflow2:
        output "Stack underflow---expected at least 2 elements\n"
        goto waiting


print_non_plural:
        output '\n'
        halt

main:

        output "IN MAIN NOW\n"
        push r1 on stack r2

        goto waiting linking r1 # going to the main loop

        pop r1 off stack r2
        goto r1

waiting:
        output "In waiting\n"
        # push r1 on stack r2 # I don't think we need this
        r1 := input()

waiting_with_character:

        if (r1 <s 0) goto done using r5 # check if we've reached EOF
        
        r5 := jumptable + r1

        r5 := m[r0][r5]

        # goes to the correct digit/command
        goto r5 

entering:
        output "In entering\n"
        r1 := input()
        if (r1 <s 0) goto done using r5                     # checking EOF

        r6 := '0'
        if (r1 <s r6) goto waiting_with_character using r5  # if r1 holds the character it will fail

        # checking to see if we get another digit to combine
        r6 := '9'
        if (r1 >s r6) goto waiting_with_character using r5 # if r1 holds the character it will fail
        output "passed comparison\n"
        
        # combining with most recent digit on the value stack
        pop r5 off stack r3
        r5 := r5 * 10
        r5 := r5 + r1
        r5 := r5 - '0'
        push r5 on stack r3             # pushing the new digit onto the stack
        goto entering
                                        # maybe an issue with pushing the number in digit, but the character in entering
digit:
        output "In digit\n"
        r1 := r1 - '0'                  # converting char to int
        push r1 on stack r3             # pushing on value stack
        # pop stack r2                # pops digit off main stack
        goto entering

done:
        pop r5 off stack r2
        goto r5

input_error:
        # r6 := m[r0][r2 + 0]
        output "Unknown character "
        output r1 # I think we can just use r1 here
        output " \n"
        goto waiting


# OPERATORS
newline:
        output "In newline\n"
        push r4 on stack r2

        r4 := r3

newline_loop:

        output "In newline_loop\n"
        
        if (r4 == valstack_end) goto newline_end_loop using r5

        r7 := m[r0][r4]  # get stack element
        
        output ">>> "
        push r1 on stack r2
        push r7 on stack r2
        goto print_word linking r1
        pop stack r2
        pop r1 off stack r2
        output '\n'

        r4 := r4 + 1 # I think we need to add
        goto newline_loop
        
newline_end_loop:
        pop r4 off stack r2
        goto waiting

add:
        output "In add\n"
        r6 := valstack_end
        r6 := r6 - r3
        output "Value stack size: "
        push r6 on stack r2
        goto print_word linking r1
        pop stack r2
        r5 := 2
        push r4 on stack r2
        if (r6 <s r5) goto underflow2 using r4
        pop r4 off stack r2

        # pop y
        pop r6 off stack r3
        # pop x
        pop r7 off stack r3

        r5 := r7 + r6
        push r5 on stack r3
        goto waiting

sub:
        output "In sub\n"
        # r6 := valstack_end
        # r6 := r6 - r3
        # r5 := 2
        # push r4 on stack r2
        # if (r6 <s r5) goto underflow2 using r4
        # pop r4 off stack r2

        # pop y
        pop r6 off stack r3
        # pop x
        pop r7 off stack r3

        r5 := r7 - r6
        push r5 on stack r3
        goto waiting

mul:
        output "In mul\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 2
        push r4 on stack r2
        if (r6 <s r5) goto underflow2 using r4
        pop r4 off stack r2

        # pop y
        pop r6 off stack r3
        # pop x
        pop r7 off stack r3

        r5 := r7 * r6
        push r5 on stack r3
        goto waiting

div:
        output "In div\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 2
        push r4 on stack r2
        if (r6 <s r5) goto underflow2 using r4
        pop r4 off stack r2

        # pop y
        pop r6 off stack r3

        push r6 on stack r2
        if (r6 == r0) goto div_by_zero using r5        # checking if denom is 0
        pop r6 off stack r2

        # pop x
        pop r7 off stack r3

        r5 := r7 / r6
        push r5 on stack r3
        goto waiting

or:
        output "In or\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 2
        push r4 on stack r2
        if (r6 <s r5) goto underflow2 using r4
        pop r4 off stack r2

        # pop y
        pop r6 off stack r3
        # pop x
        pop r7 off stack r3

        r5 := r7 | r6
        push r5 on stack r3
        goto waiting

and:
        output "In and\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 2
        push r4 on stack r2
        if (r6 <s r5) goto underflow2 using r4
        pop r4 off stack r2

        # pop y
        pop r6 off stack r3
        # pop x
        pop r7 off stack r3

        r5 := r7 & r6
        push r5 on stack r3
        goto waiting

c:
        output "In c\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 1
        push r4 on stack r2
        if (r6 <s r5) goto underflow1 using r4
        pop r4 off stack r2

        # pop y
        pop r6 off stack r3
        
        r6 := - r6
        push r6 on stack r3
        goto waiting

not:
        output "In not\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 1
        push r4 on stack r2
        if (r6 <s r5) goto underflow1 using r4
        pop r4 off stack r2

        # pop y
        pop r6 off stack r3
        
        r6 := ~ r6
        push r6 on stack r3
        goto waiting

swap: 
        output "In swap\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 2
        push r4 on stack r2
        if (r6 <s r5) goto underflow2 using r4
        pop r4 off stack r2

        r5 := m[r0][r3]      # y
        r4 := m[r0][r3 + 1]  # x
        m[r0][r3]     := r4 # idk if we can do this
        m[r0][r3 + 1] := r5
        goto waiting

dup:
        output "In dup\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 1
        push r4 on stack r2
        if (r6 <s r5) goto underflow1 using r4
        pop r4 off stack r2

        r5 := m[r0][r3]
        push r5 on stack r3
        goto waiting

pop_stack:
        output "In pop\n"
        r6 := valstack_end
        r6 := r6 - r3
        r5 := 1
        push r4 on stack r2
        if (r6 <s r5) goto underflow2 using r4
        pop r4 off stack r2

        pop stack r3
        goto waiting

zero:
        output "In zero\n"
        r3 := valstack_end
        goto waiting

div_by_zero:
        output "Division by zero\n"
        r6 := m[r0][r2 + 0]
        push r6 on stack r3     # putting value back onto the value stack

        pop stack r2

        goto waiting
